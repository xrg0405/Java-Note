# JAVA笔记-020

[TOC]

## 转换流

- 转换流提供了在字节流和字符流之间的转换
- JAVA API中提供了两个转换流：
  - InputStreamReader：将InputStream转换为Reader
  - OutputStreamWriter：将Writer转换为OutputStream
- 字节流中的数据都是字符时，专程字符流操作更高效
- 很多时候使用转换流来处理文件乱码问题，实现编码和解码的功能



## 对象的序列化

- 凡是实现Serializable接口的类都有一个表示序列化版本标识符的静态变量：
  - ==private static final long serivalVersionUID==；
  - serivalVersionUID用来表明类的不同版本间的兼容性
  - 如果类没有显示定义这个静态变量，它的值是Java运行时环境根据类的内部细节自动生成的。==若类的实例变量做了修改，serivalVersionUID可能发生变化，故建议使用显示声明
- Java的序列化机制是通过在运行时判断类的serivalVersionUID来检验版本一致性的。
- 在进行反序列化时，JVM会把传来的字节流中的serivalVersionUID与本地相应实体类的serivalVersionUID进行比较，如果相同，就认为是一致的，可以进行反序列化，否则就会出现序列化版本不一致的异常（InvalidCastException）



## NIO介绍

- NIO支持面向缓冲区的（IO是面向流的）、基于通道的IO操作。NIO将以更高级的方式进行文件的读写操作。
- Java API中提供了两套NIO，一套是针对标准输入输出NIO，另一套就是网络编程NIO。
- java.nio.channels.Channel
  -  FIleChannel : 处理本地文件
  - SocketChannel : TCP网络编程的客户端的Channel
  - ServerSocketChannel : TCP网络编程的服务器端的Channel
  - DatagramChannel : UDP网络编程中发送端和接收段的Channel



## 网络编程概述

**网络编程中有两个主要的问题：**

- 如何准确地定位网络上一台或多台主机；定位主机上的特定应用
  - ==通信双方地址==
    - IP
    - 端口号
- 找到主机后如何可靠高效地进行数据传输
  - ==网络通讯协议==
    - OSI参考模型：过于理想化，未能推广
    - TCP/IP参考模型（协议）：现在使用的国际标准

**本地回路地址：**127.0.0.1

**端口号标识正在计算机上运行的进程（程序）**

- 不同的进程有不同的端口号
- 被规定为一个16位的整数0～65535
- 端口分类：
  - **公认端口：**0～1023.被预先定义的服务通信占用（如：HTTP占用端口80，FTP占用端口21，TeInet占用端口23）
  - **注册端口：**1024～49151.分配给用户进程或应用程序。（如：Tomcat占用端口8080、MySQL占用端口3306，Oracle占用端口1521等）
  - **动态/私有端口：**49152～65535
- ==端口号和IP地址的组合得出一个网络套接字：Socket==



## 网络通信协议

- 计算机网络中实现通信必须有一些约定，即通信协议，对速率、传输代码、代码结构、传输控制步骤、出错控制等指定标准



**通信协议分成的思想：**

- 在制定协议时，把复杂成分分解成一些简单的成分，再将它们复合起来。最常用的复合方式是层次方式，即同成间可以通信、上层可以调用下一层，而与再下层不发生关系。各层互不影响，利于系统的开发拓展



**TCP和UDP协议**

- ==TCP协议：==
  - 使用TCP协议前，必须先建立TCP连接，形成传输数据通道
  - 传输前，采用“三次握手”方式，点对点通信，是可靠的
  - TCP协议进行通信的两个应用程序：客户端、服务端
  - 在连接中可进行大数据量的传输
  - 传输完毕，需要释放已经建立的连接，效率低
- ==UDP协议==
  - 将数据、源、目的封装成数据包，不需要建立连接
  - 每个数据报的大小限制在64K内
  - 发生不管对方是否准备好，接收方收到也不确认，因此是不可靠的
  - 可以广播发送
  - 发送数据结束时无需释放资源，开销小，速度快



## URL编程

- URL：同一资源定位符，它表示Internet上某一资源的地址
- URL的基本结构由5部分组成：
  - ==<传输协议>://<主机名>:<端口号>/<文件名>#片段名?参数列表==

